---
title: "Building and publishing a Docker image with Packer"
date: 2021-08-01
tags: [DevOps,Docker,Packer,HCL]
draft: false
---

A few weeks ago I was playing around with the [Hashicorp](https://www.hashicorp.com/) stack using [Vagrant](https://www.vagrantup.com/), [Nomad](https://www.nomadproject.io/) and [Consul](https://www.consul.io/). I was just trying to build a cluster of machines to deploy a Docker-based Golang service. I could have done the work with Dockerfiles directly to provision the container, but I decided instead to give [Packer] a try.

Packer is a Hashicorp tool used to provision virtual machine images to be used in multiple cloud-providers (e.g. AWS, Azure, Oracle, etc...) However, it can also be used to provision Docker containers.

In this post, I am going to walk through what I did to take a simple Docker Golang service, build it as a Docker container and then push it to Docker hub. 

**Note**: All of the source code for this project can be found [here](https://github.com/thoughtmechanix-public/orders_service_terraform_example).

### Why did I choose Go for my microservice example?
I have worked with a lot of different programming languages throughout my career.  Many of them are excellent languages.
I chose Go because frankly it is super simple to learn and compiles down to a single native, binary executable. A single binary executable makes provisioning containers a stack because you are usually only worried about installing and configuring one thing, the binary, when you are provisioning you are a container. I will take simplicity any day of the week.

### Building the Go microservice
All code for the Go service is located in the `src` directory of the Github repository.  This simple service does nothing more then expose a `/healthcheck` endpoint on port `8888`. In a *nix environment you can run the `make` file command to build the project. If you are running in a Windows environment, you can change to the `src` directory and run `go build`.

### Building the Docker Container
Once you have a binary you can build the Docker container using Packer. Packer lets you declaratively define how you want to provision a virtual image or container in a human readable text format. Packer supports two different markup languages for defining the provisioning process: JSON and HCL (Hashicorp Markup Language). For this example, we are going to use HCL. HCL tends to be much less verbose then JSON and since I was doing this work in the context of other Hashicorp projects (Nomand and Consul) I wanted to stick with HCL as this is the most popular markup language used in these other tools.

I am not going to walk the syntax of HCL here. For a well-written explanation of HCL, I suggest you take a look Adam Bertram's excellent overview of the subject [here](https://octopus.com/blog/introduction-to-hcl-and-hcl-tooling).

**Note:**  If you are going to use HCL with Packer, your provisioning file needs to end in `.hcl`.

Let's go ahead and walk through what is in our Packer provisioning file. This file is located in the `provision` directory and called `orders.pkr.hcl`. 

In the `orders.pkr.hcl` file above we have four key activities:

1. Defining the plugins used we are going to use in Packer.

2. Defining input variables for values for generalizing the build.

3. Configuring the Docker image we are going to build our image from.

4. Building Docker container and pushing it to Docker hub.

The code contained in this file looks like this:

```hcl

#Defining the plugins used we are going to use in Packer.
packer {
  required_plugins {
    docker = {
      version = ">= 1.0.1"
      source  = "github.com/hashicorp/docker"
    }
  }
}

#Defining input variables for values for generalizing the build.
variable  "docker_repo" {
  type = string
  sensitive = true
}

variable  "docker_username" {
  type = string
  sensitive = true
}

variable "docker_password" {
  type = string
  sensitive = true
}

#Configuring the Docker image we are going to build our image from
source "docker" "golang" {
  image       = "golang"
  commit      = true
  pull        = true
  changes = [
    "EXPOSE 8888 8888",
    "ENTRYPOINT [\"/bin/orders\"]"
  ]
}

#Building Docker container and pushing it to Docker hub.
build {
  sources = ["source.docker.golang"]

  provisioner "file" {
    source      = "../bin/orders"
    destination = "/bin/"
  }
  
  post-processors {
    post-processor "docker-tag" {
      repository = var.docker_repo
      tags       = ["1.0"]
    }

    post-processor "docker-push" {
      login=true
      login_username = var.docker_username
      login_password = var.docker_password
    }
  }  
}
```

#### Defining the plugins used we are going to use in Packer.
All HCL files contain one or more stanzas in them. A stanza defines a discrete piece of functionality that is going to 
be carried out by the application processing the block. In the case of our Packer file, the first stanze intializes Packer
and tells it what "plugins" are going to be used in. The plugin are how Hashicorp makes their products extensible. Some of their products (e.g. Terraform) allow the open source community to write and contribute plugins. In the case of Packer, each different environment in which you can provision a VM or Docker container instance is its own plugin.

```hcl {linenos=table,hl_lines=[4,5],linenostart=1}
packer {
  required_plugins {
    docker = {
      version = ">= 1.0.1"
      source  = "github.com/hashicorp/docker"
    }
  }
}
```

Packer's plugin system uses semantic versioning to determine what version of a plugin in should be used with this configuration.  In the lines 4 and 5 above, we are indicating that this script can use any of the Focker plugins that are of version 1.0.1. or higher.

**Note**: The `source` attribute above does not match exactly to the Hashicorp source control repository. The source for the Docker plugin can be found [here].


#### Defining input variables for values for generalizing the build
Packer allows you to generalize your provisioning scripts by allowing you to define variables. Packer has three types of variables: `input`, `output`, and `local`. In this blog post we are only going to demonstrate the usage of input variables. Input variables are set before the configuration is processed. At runtime, these variables can be set by passing them in the command-line or as environment variables.

In our Packer configuration we define three input variables that will be used to control how we publish our built Docker image to a Docker repository (e.g. Docker Hub):  

1. **docker_repo**. The Docker repository we are going to publish the image to. For this project I used Docker Hub.

2. **docker_username**. The Docker Hub account user name the Pacler configuration is going to use for publication.

3. **docker_password**. The Docker Hub account password the Packer configuration is going to use for publication.

```hcl {linenos=table,hl_lines=[1,6,11],linenostart=1}
variable  "docker_repo" {
  type = string
  sensitive = true
}

variable  "docker_username" {
  type = string
  sensitive = true
}

variable "docker_password" {
  type = string
  sensitive = true
}
```

We are only scratching the surface on Packers variable capabilities. For a much more detailed description of Packer's variable system please take a look at the Packer [site](https://www.packer.io/guides/hcl/variables).

#### Configuring the Docker image we are going to build our image from.
Next we are going to define how we are going to configure the base Docker image we are going to use for a build. To do this we are going to use the Packer `source` stanze.

```hcl
source "docker" "golang" {
  image       = "golang"
  commit      = true
  pull        = true
  changes = [
    "EXPOSE 8888 8888",
    "ENTRYPOINT [\"/bin/orders\"]"
  ]
}
```

In our `source` stanze above we are telling Packer we are going to use the `docker` source for configuration. We give the source a logical name (e.g. golang). Then we provide configure the source via number of attributes. They include:

1. **image**. This indicates the Docker hub image we are going to build our image from. In this case the image we are going to use is the golang image and it can be found [here](https://hub.docker.com/_/golang).

2. **commit**. The `commit` attribute is a boolean value that will tell Packer whether container we are building will be committed to an image or tarred up into a tar file. If the `commit` attribute is set to `true` the container will be committed to a Docker image that can be pushed to a Docker registry (e.g. Docker Hub). If the attribute is set to false, container being created will be packaged up as a tar file. 

3. **pull**. The `pull` attribute is a boolean value that will tell Packer whether or not it should try to pull from Docker hub before it tries to build. If the attribute is `true` Packer will do a pull from Docker hub. If the attribute is `false` the image will assumed to be in the local Docker repository running on the machine running Packer and will not attemp to pull it from Docker hub.

4. **changes**. This is the main configuration point for changes we are going to make to our Docker container. In the example above, we are going to expose port `8888` on the Docker container we are building and tell Docker that when the container is started it shoudl run `/bin/orders`. This is the where the `orders` binary is going to be placed when the container image is built. Remember, the `orders` binary was built in the `Building the Go microservice` section of the blog.

#### Building Docker container and pushing it to Docker hub.








